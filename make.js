/**
 * Usage: node make.js
 *
 * Sorts fields, removes default values, and formats all difficulties and rebuilds README.md to include entries for each
 */

const fs = require('fs');
const path = require('path');

const base = JSON.parse(fs.readFileSync('base.cd.json'));

const keys = [
  'Name',
  'Description',
  'MaxActiveCritters',
  'MaxActiveSwarmers',
  'MaxActiveEnemies',
  'ResupplyCost',
  'StartingNitra',
  'ExtraLargeEnemyDamageResistance',
  'ExtraLargeEnemyDamageResistanceB',
  'ExtraLargeEnemyDamageResistanceC',
  'ExtraLargeEnemyDamageResistanceD',
  'EnemyDamageResistance',
  'SmallEnemyDamageResistance',
  'EnemyDamageModifier',
  'EnemyCountModifier',
  'EncounterDifficulty',
  'StationaryDifficulty',
  'EnemyWaveInterval',
  'EnemyNormalWaveInterval',
  'EnemyNormalWaveDifficulty',
  'EnemyDiversity',
  'StationaryEnemyDiversity',
  'VeteranNormal',
  'VeteranLarge',
  'DisruptiveEnemyPoolCount',
  'MinPoolSize',
  'MaxActiveElites',
  'EnvironmentalDamageModifier',
  'PointExtractionScalar',
  'FriendlyFireModifier',
  'WaveStartDelayScale',
  'SpeedModifier',
  'AttackCooldownModifier',
  'ProjectileSpeedModifier',
  'HealthRegenerationMax',
  'ReviveHealthRatio',
  'EliteCooldown',
  'EnemyDescriptors',
  'EnemyPool',
  'CommonEnemies',
  'SpecialEnemies',
  'DisruptiveEnemies',
  'StationaryEnemies',
  'SeasonalEvents',
  'EscortMule'
];

keyOrder = new Map(keys.map((i, k) => [i, k]));

const specialKeys = new Map([
  ['min', 'max'],
  ['weight', 'range'],
  ['clear', 'add', 'remove']
].map((o, i) => o.map((k, j) => [k, `_${String(j).padStart(4, '0')}_${k}`])).flat());

function compareSet(a, b) {
  if (a.length !== b.length) return false;
  return a.every(v => b.has(v));
}

function getKeys(obj) {
  const toReturn = [];
  const keys = Array.isArray(obj) ? obj.keys() : Object.keys(obj);
  for (let i of keys) {
    toReturn.push([i])
    if ((typeof obj[i]) == 'object') {
      for (let j of getKeys(obj[i])) {
        toReturn.push([i, ...j]);
      }
    }
  }
  return toReturn;
};

function getKeyIndex(key, index) {
  if (key.length <= index) throw new Error(`Index out of of bounds for key`);
  return key[index];
}

function getKeyIndexDifficulty(key, index) {
  if (key.length <= index) throw new Error(`Index out of of bounds for key`);
  const v = key[index];
  if (index === 0) {
    if (!keyOrder.has(v)) throw new Error(`Unknown property: "${v}"`);
    return keyOrder.get(v);
  } else {
    return specialKeys.has(v) ? specialKeys.get(v) : v;
  }
}

function compareValue(a, b) {
  if (typeof a !== typeof b) {
    throw new Error(`Mismatched types: "${typeof a}" and "${typeof b}"`);
  }
  if (typeof a === 'string') {
    return a.localeCompare(b);
  } else if (typeof a === 'number') {
    return a - b;
  }
  throw new Error('Unknown type');
}

function getComparator(mappingFn) {
  return (a, b) => {
    for (let i = 0; ; i++) {
      if (a.length !== b.length) {
        if (a.length <= i) return -1;
        if (b.length <= i) return 1;
      }
      const diff = compareValue(mappingFn(a, i), mappingFn(b, i));
      if (diff !== 0) return diff;
    }
  }
}

function getSortedKeys(difficulty, mappingFn) {
  return getKeys(difficulty).sort(getComparator(mappingFn));
}

function sortedStringify(obj) {
  return JSON.stringify(obj, getSortedKeys(obj, getKeyIndex).flat());
}

function deepEquals(a, b) {
  return sortedStringify(a) === sortedStringify(b);
}

function loadDifficulty(path) {
  const difficulty = JSON.parse(fs.readFileSync(path));
  return {
    ...base,
    ...difficulty
  };
}

function formatDifficulty(path) {
  let difficulty = loadDifficulty(path);
  for (let key of Object.keys(difficulty)) {
    if (deepEquals(difficulty[key], base[key])) {
      delete difficulty[key];
    }
  }
  fs.writeFileSync(path, JSON.stringify(difficulty, getSortedKeys(difficulty, getKeyIndexDifficulty).flat(), 2));
}

function getFiles(dir, files_){
    files_ = files_ || [];
    const files = fs.readdirSync(dir);
    for (let i in files){
        const name = dir + '/' + files[i];
        if (fs.statSync(name).isDirectory()){
            getFiles(name, files_);
        } else {
          if (/\.cd\.json$/.test(name)) files_.push(name);
        }
    }
    return files_;
}

function getDifficulties() {
  const paths = getFiles('difficulties');
  return paths.map(p => ({
    path: p,
    difficulty: loadDifficulty(p)
  }));
}

function makeReadmeSection(header, title, body) {
  return `${'#'.repeat(header)} ${title}\n${body}\n`;
}

function makeReadme(entries) {
  const sections = [];
  sections.push(makeReadmeSection(1, 'Custom Difficulties', `This is collection of difficulties to be used with the [Custom Difficulty](https://drg.mod.io/custom-difficulty) mod for Deep Rock Galactic.

A list of EnemyDescriptors and PawnStats can be found in [DATA.md](DATA.md)

Note: This README.md is generated by \`make.js\`. Before commiting changes, run \`node make.js\` to format difficulties and regerate this difficulty listing.`));
  for (let e of entries) {
    sections.push(makeReadmeSection(2, `[${e.difficulty.Name}](${e.path.split(path.sep).join('/')})`, e.difficulty.Description));
  }
  fs.writeFileSync('README.md', sections.join('\n'));
}


function make() {
  const entries = getDifficulties();
  for (let e of entries) {
    formatDifficulty(e.path);
  }
  makeReadme(entries);
}

make();
